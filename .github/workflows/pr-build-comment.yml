name: pr-build-preview-comment

on:
  workflow_run:
    workflows: ["pr-build-preview"]
    types: [completed]

permissions:
  actions: read
  contents: read
  issues: write
  pull-requests: write

jobs:
  comment:
    # Only publish a comment for pull_request-triggered runs (fork PRs included).
    if: github.event.workflow_run.event == 'pull_request' && github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest

    steps:
      - name: Download PR build metadata
        # This workflow runs in the base repository context, so it can comment on PRs even for fork builds.
        uses: actions/download-artifact@v4
        with:
          name: pr-build-metadata
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ github.token }}
          path: pr-build-metadata

      - name: Comment build info on PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");

            const workflowRun = context.payload.workflow_run;
            const metadataPath = "pr-build-metadata/pr-build-metadata.json";

            // PR association is not guaranteed in `workflow_run.pull_requests` (it can be empty even when
            // the upstream run was triggered by `pull_request`). We use the upstream workflow's metadata
            // artifact for display info, and resolve the PR number via trusted event/API signals.
            let metadata = {};
            try {
              const metadataRaw = fs.readFileSync(metadataPath, "utf8");
              metadata = JSON.parse(metadataRaw);
            } catch (error) {
              core.warning(`Failed to read PR build metadata from ${metadataPath}: ${error.message}`);
            }

            const prNumberFromPayload = Number((workflowRun.pull_requests || [])[0]?.number);
            const prNumberFromMetadata = Number(metadata.prNumber);

            // Prefer PR number from the event payload (trusted). When it is missing, resolve the PR using the
            // workflow run's head repository + branch (works for fork PRs where `pull_requests` is empty).
            let prNumber = Number.isInteger(prNumberFromPayload) && prNumberFromPayload > 0 ? prNumberFromPayload : null;

            if (!prNumber) {
              const headOwner = workflowRun.head_repository?.owner?.login;
              const headBranch = workflowRun.head_branch;
              const headSha = workflowRun.head_sha;

              if (headOwner && headBranch) {
                try {
                  core.info(`Attempting to resolve PR from ${headOwner}:${headBranch} (SHA: ${headSha?.slice(0, 7)})`);

                  const { data: prs } = await github.rest.pulls.list({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    head: `${headOwner}:${headBranch}`,
                    state: "all",
                    per_page: 10,
                  });

                  const exactMatch = Array.isArray(prs) ? prs.find((pr) => pr?.head?.sha === headSha) : null;
                  prNumber = (exactMatch || prs?.[0])?.number ?? null;
                } catch (error) {
                  core.warning(`Unable to resolve PR from head ${headOwner}:${headBranch}: ${error.message}`);
                }
              }
            }

            // Last resort: fall back to the metadata artifact (generated by the upstream workflow) if we still
            // couldn't resolve the PR number. This keeps the comment workflow functional even if GitHub API
            // lookups are temporarily unavailable.
            if (!prNumber && Number.isInteger(prNumberFromMetadata) && prNumberFromMetadata > 0) {
              core.info(`Falling back to PR number from metadata: #${prNumberFromMetadata}`);
              prNumber = prNumberFromMetadata;
            }

            if (!prNumber) {
              core.warning("Unable to determine PR number for workflow_run; skipping comment.");
              return;
            }

            core.info(`Processing comment for PR #${prNumber}`);

            const marker = "<!-- pr-build-artifact -->";
            const commitSha = String(metadata.commitSha || workflowRun.head_sha || "");

            const artifactFiles = Array.isArray(metadata.artifactFiles) ? metadata.artifactFiles : [];
            const artifactList = artifactFiles.length
              ? artifactFiles.map((name) => `- ${name}`).join("\n")
              : "- (none)";

            const runUrl = workflowRun.html_url || `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${workflowRun.id}`;

            const body = [
              marker,
              `**Preview build ready** for commit \`${commitSha.slice(0, 7)}\`.`,
              "",
              "Artifacts:",
              artifactList,
              "",
              `Download from workflow run: ${runUrl}`,
              "",
              "_This build is for review only and is not released._",
            ].join("\n");

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const existing = comments.find((comment) => comment.body && comment.body.includes(marker));

            if (existing) {
              core.info(`Updating existing comment (ID: ${existing.id})`);
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              core.info(`Creating new comment on PR #${prNumber}`);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body,
              });
            }
